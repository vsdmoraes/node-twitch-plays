/* This is a phantomjs script and needs to be run with phantomjs binary */
'use strict'

var webpage = require('webpage')
var system = require('system')
system.stdin.setEncoding('utf8')
system.stdout.setEncoding('utf8')

var _running = false
var _showMode = false // if true take screenshot after every event

phantom.onError = function (msg, trace) {
  var tokens = msg.split(/[ :]/g)
  emit({ error: 'phantom error: ' + msg, text: msg })
  phantom.exit(1)
}

start()

function emit (json) {
  var line = JSON.stringify(json)
  system.stdout.write(line + '\n')
  system.stdout.flush()
}

function start () {
  _running = true
  nextTick()
}

var _pages = []

function deepMerge (a, b) {
  Object.keys(b).forEach(function (key) {
    if (typeof a[key] === 'object' && typeof b[key] === 'object') {
      a[key] = deepMerge(deepMerge({}, a[key]), b[key])
    } else {
      a[key] = b[key]
    }
  })
  return a
}

function createPage (opts) {
  var _pageIndex = _pages.length
  opts = opts || {}

  if (!opts.viewportSize) {
    opts.viewportSize = {
      width: 720,
      height: 540
    }
  }

  var _page = webpage.create()

  // Object.keys(opts).forEach(function (key) {
  //   deepMerge(_page[key], opts[key])
  //   // if (typeof _page[key] === 'object' && opts[key] === 'object') {
  //   //   _page[key] = Object.assign({}, _page[key] || {}, opts[key])
  //   // } else {
  //   //   _page[key] = opts[key]
  //   // }
  // })

  // emit({ log: 'before -- userAgent: ' + _page.settings.userAgent })
  // emit({ log: 'before  -- loadImages: ' + _page.settings.loadImages })
  // emit({ log: 'before  -- viewportSize: ' + JSON.stringify(_page.viewportSize) })

  deepMerge(_page, opts)
  // set default userAgent
  if (!opts || !opts.settings || opts.settings.userAgent == null) {
    _page.settings.userAgent += ' PinkyJS/' + system.env.version + ' @talmobi'
  }

  // emit({ log: 'after  -- userAgent: ' + _page.settings.userAgent })
  // emit({ log: 'after  -- loadImages: ' + _page.settings.loadImages })
  // emit({ log: 'after  -- viewportSize: ' + JSON.stringify(_page.viewportSize) })

  _page.__errors = []

  _page.onConsoleMessage = function (msg, lineNu, sourceId) {
    emit({ debug: '[PAGE CONSOLE]: ' + msg })
  }

  _page.onError = function (msg, trace) {
    var tokens = msg.split(/[ :]/g)
    var m = msg.toLowerCase()

    _page.__errors.push({
      msg: msg,
      tokens: tokens,
      pageIndex: _pageIndex
    })
    emit({ pageIndex: _pageIndex, pageError: 'page error: ' + msg })
  }

  _page._opts = opts
  _pages.push(_page)
  return _pageIndex
}

var _timeout
function nextTick (delay) {
  setTimeout(function () {
    if (_running) {
      clearTimeout(_timeout)

      _pages.forEach(function (page, index) {
        var opts = page._opts
        if (opts.camera && page._opened) {
          // render showMode page
          emit({ debug: ' >> [showMode]: rendering page...' })
          var result = page.renderBase64('JPEG') // default to JPEG
          emit({ debug: ' >> [showMode]: page rendered as base64' })
          emit({ pageIndex: index, type: 'camera', result: result })
        }
      })

      _timeout = setTimeout(tick, delay || 175)
    } else {
      emit({ type: 'exit' })
      phantom.exit()
    }
  }, 25)
}

function tick () {
  var line = system.stdin.readLine()
  var json = JSON.parse(line)

  // check that page is opened for events that require it
  switch (json.type) {
    case 'heartbeat':
    case 'create':
    case 'open':
    case 'exit':
    case 'echo':
    case 'close':
      break
    default:
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]
      if (!page._opened) {
        emit({ error: 'page is closed -- attempting to use closed page error' })
        return nextTick()
      }
  }

  switch (json.type) {
    case 'heartbeat':
      emit({ type: 'heartbeat', date: Date.now() })
      nextTick()
      break

    case 'create':
      emit({ debug: 'creating page...' })
      var pageIndex = createPage(json.opts)
      var page = _pages[pageIndex]
      emit({ pageIndex: pageIndex, type: 'create' })
      nextTick()
      break

    case 'open':
      emit({ debug: 'opening page url [' + json.url + ']' })
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]

      // TODO
      // ignore first open (often fails)
      // page.open(json.url, function (status) {
      // })

      if (page._opened) { // reuse the pageIndex for a new page
        var opts = page._opts
        page.close()
        var index = createPage(opts) // create new page
        page = _pages.pop() // pop off the newest page
        _pages[pageIndex] = page // replace the pageIndex with the new page
        page = _pages[pageIndex] // continue ops on the new page
      } else {
        if (typeof page.open !== 'function') {
          try {
            page.close()
          } catch (err) {}

          var opts = page._opts
          var index = createPage(opts) // create new page
          page = _pages.pop() // pop off the newest page
          _pages[pageIndex] = page // replace the pageIndex with the new page
          page = _pages[pageIndex] // continue ops on the new page
        }
      }

      var openingAttempts = 0
      var MAX_ATTEMPTS = 6

      var open = function () {
        page.open(json.url, function (status) {
          if (page.__errors
              .filter(function (err) {
                return err.msg.toLowerCase().indexOf('net::') === -1
              })
              .filter(function (err) {
                return err.msg.toLowerCase().indexOf('undefined') > 0
              })
              .filter(function (err) {
                return err.msg.toLowerCase().indexOf('evaluating') > 0
              })
              .length > 0) {
            page.close()
            var index = createPage(opts) // create new page
            page = _pages.pop() // pop off the newest page
            openingAttempts++
            _pages[pageIndex] = page // replace the pageIndex with the new page
            page = _pages[pageIndex] // continue ops on the new page

            emit({ debug: ' ------ ' })
            emit({ debug: 'fatal page open errors -- reopening...' })
            emit({ debug: 'opening attempts: [' + openingAttempts +']' })
            emit({ debug: ' ------ ' })

            if (openingAttempts < MAX_ATTEMPTS) {
              setTimeout(function () {
                open()
              }, 250)
            } else {
              emit({
                pageIndex: pageIndex,
                type: 'open',
                error: 'failed to open page (too many failed attempts)'
              })
              // phantom.exit(1)
            }
          } else {
            emit({ debug: 'page open callback, status: ' + status })

            if (status !== 'success') {
              if (openingAttempts < MAX_ATTEMPTS) {
                openingAttempts++
                page.close()
                var index = createPage(opts) // create new page
                page = _pages.pop() // pop off the newest page
                openingAttempts++
                _pages[pageIndex] = page // replace the pageIndex with the new page
                page = _pages[pageIndex] // continue ops on the new page

                emit({ debug: ' ------ ' })
                emit({ debug: 'page failed to open.. reopening...' })
                emit({ debug: 'opening attempts: [' + openingAttempts +']' })
                emit({ debug: ' ------ ' })

                setTimeout(function () {
                  open()
                }, 250)
              } else {
                emit({
                  pageIndex: pageIndex,
                  type: 'open',
                  error: 'failed to open page (too many failed attempts)'
                })
              }
              // phantom.exit(1)
            } else {
              // make sure page actually loaded successfully
              var documentElementFound = page.evaluate(function (url) {
                if (!document.body.bgColor) {
                  document.body.bgColor = 'white'
                }

                var hostname = document.location.hostname.toLowerCase()
                var pathname = document.location.pathname.toLowerCase()

                return !!(
                  document.documentElement &&
                  url.indexOf(hostname) > 0 &&
                  url.indexOf(pathname) > 0
                )
              }, json.url.toLowerCase())
              if (documentElementFound) {
                emit({ debug: 'page opened ' + status })
                page._opened = true
                emit({ pageIndex: pageIndex, type: 'open' })
                nextTick()
              } else {
                emit({ pageIndex: pageIndex, type: 'open', error: 'document.documentElement not found' })
                // phantom.exit(1)
              }
            }
          }
        })
      }
      open()
      break

    case 'wait':
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]

      emit({ debug: 'waiting for: ' + json.querySelector })
      var hasTimedOut = false

      var waitTimeout = setTimeout(function () {
        hasTimedOut = true
        emit({ pageIndex: pageIndex, debug: 'wait timed out', type: 'wait' })
        emit({ pageIndex: pageIndex, error: 'wait timed out', type: 'wait' })
        setTimeout(function () {
          nextTick()
        }, 333)
        // phantom.exit(1)
      }, json.timeoutTime || 25 * 1000)

      var waitTick = function () {
        setTimeout(function () {
          if (hasTimedOut) return undefined

          var result = page.evaluate(function (querySelector) {
            return !!(document.querySelector(querySelector))
          }, json.querySelector)

          if (!!result) {
            clearTimeout(waitTimeout)
            emit({ pageIndex: pageIndex, type: 'wait' })
            setTimeout(function () {
              nextTick()
            }, 100)
          } else {
            emit({ pageIndex: pageIndex, debug: 'wait result falsy' })
            setTimeout(waitTick, 200)
          }
        }, 125)
      }
      waitTick()
      break

    case 'waitEval':
    case 'waitEvaluate':
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]

      emit({ debug: 'waiting evaluating...: ' + json.querySelector })
      var hasTimedOut = false

      var waitTimeout = setTimeout(function () {
        hasTimedOut = true
        emit({ pageIndex: pageIndex, debug: 'waitEvaluate timed out', type: 'waitEvaluate' })
        emit({ pageIndex: pageIndex, error: 'waitEvaluate timed out', type: 'waitEvaluate' })
        setTimeout(function () {
          nextTick()
        }, 333)
        // phantom.exit(1)
      }, json.timeoutTime || 25 * 1000)

      var waitEvalTick = function () {
        setTimeout(function () {
          if (hasTimedOut) return undefined

          try {
            var fnParams = parseFunctionParams(json.callback)
            var fnBody = parseFunctionBody(json.callback)
            var fn = Function(fnParams, fnBody)
            var result = page.evaluate(fn, json.argument)

            if (!!result) {
              clearTimeout(waitTimeout)
              emit({ pageIndex: pageIndex, type: 'waitEvaluate', result: result })
              setTimeout(function () {
                nextTick()
              }, 100)
            } else {
              emit({ pageIndex: pageIndex, debug: 'waitEvaluate result falsy' })
              setTimeout(waitEvalTick, 200)
            }
          } catch (err) {
            emit({ pageIndex: pageIndex, type: 'waitEvaluate', error: JSON.stringify(err) })
          }

          nextTick()
        }, 125)
      }
      waitEvalTick()
      break

    case 'keyboard':
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]

      emit({ debug: 'typing: ' + json.text })
      if (json.querySelector) {
        page.evaluate(function (qs) {
          document.querySelector(qs).focus()
        }, json.querySelector)
      }

      emit({ debug: 'sending keypresses' })
      // page.sendEvent('keypress', json.text)

      if (typeof json.key === 'string') {
        var letters = json.key.split('')
        var letterIndex = 0
        var letterTick = function () {
          page.sendEvent('keypress', letters[letterIndex++])
          if (letterIndex < letters.length) {
            setTimeout(letterTick, 25 + letterIndex % 25)
          } else {
            setTimeout(function () {
              emit({ pageIndex: pageIndex, type: 'keyboard' })
              nextTick()
            }, 125)
          }
        }
        setTimeout(letterTick, 10 + 100 * letterIndex)
      } else {
        setTimeout(function () {
          page.sendEvent('keypress', json.key)
          setTimeout(function () {
            emit({ pageIndex: pageIndex, type: 'keyboard' })
            nextTick()
          }, 125)
        }, 250)
      }
      break

    case 'click':
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]
      var opts = json.opts

      emit({ debug: 'clicking querySelector: ' + json.querySelector })
      // emit({ log: 'clicking: ' + json.querySelector })

      // calculate position of the element we want to click
      // AND ALSO scroll down the viewport to include
      // the element we want to click on -- otherwise
      // you will be clicking on effectively outside of the window..
      var rect = page.evaluate(function (qs) {
        var br = document.querySelector(qs).getBoundingClientRect()
        var height = window.innerHeight
        var delta = (br.top + br.height) - height
        if (delta > 0) document.body.scrollTop = delta
        return document.querySelector(qs).getBoundingClientRect()
      }, json.querySelector)

      // emit({ log: 'rect: ' + JSON.stringify(rect) })

      page.evaluate(function (qs) {
        // document.querySelector(qs).onclick = function (e) {
        document.querySelector(qs).click = function (e) {
          document.querySelector(qs).style.display = 'none'
        }
      }, json.querySelector)

      for (var i = 0; i < 1; i++) {
        page.sendEvent(
          'click',
          Math.round(rect.left + rect.width / 2),
          Math.round(rect.top + rect.height / 2),
          opts.button || 'left'
        )
      }

      // page.evaluate(function (qs) {
      //   document.querySelector(qs).click()
      // }, json.querySelector)

      // see where you clicked during showMode
      if (page._opts.showMode) {
        page.evaluate(function (r) {
          // draw small red circle on click point
          var c = document.createElement('div')
          c.style.pointerEvents = 'none'
          c.style.display = 'block'
          c.style.position = 'fixed'
          c.style.backgroundColor = 'red'
          c.style.width = '12px'
          c.style.height = '12px'
          c.style.borderRadius = '50%'
          c.style.left = (r.left + r.width / 2 - 6) + 'px'
          c.style.top = (r.top + r.height / 2 - 6) + 'px'

          setTimeout(function () {
            c.parentNode.removeChild(c)
          }, 1000)

          document.body.appendChild(c)
        }, rect)
      }

      setTimeout(function () {
        emit({ pageIndex: pageIndex, type: 'click' })
        nextTick()
      }, 150)
      break

    case 'sendEvent':
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]

      emit({ debug: 'sending event...' })
      emit({ debug: 'evt args: [' + json.args.join(', ') + ']' })
      var args = json.args
      page.sendEvent.apply(this, args)
      emit({ debug: 'event sent' })
      emit({ pageIndex: pageIndex, type: 'sendEvent' })
      nextTick()
      break

    case 'render':
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]

      // eval before render
      // page.evaluate(function () {
      //   return document.documentElement.outerHTML
      // })

      setTimeout(function () {
        emit({ debug: 'rendering page...' })
        page.render(json.fileName)
        emit({ debug: 'saved to [' + json.fileName + ']' })
        emit({ pageIndex: pageIndex, type: 'render', result: 'screen.png' })
        nextTick()
      }, 25)
      break

    case 'renderBase64':
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]

      // eval before render
      // page.evaluate(function () {
      //   return document.documentElement.outerHTML
      // })

      setTimeout(function () {
        emit({ debug: 'rendering page...' })
        var result = page.renderBase64(json.format || 'PNG') // default to PNG format
        emit({ debug: 'page rendered as base64' })
        emit({ pageIndex: pageIndex, type: 'renderBase64', result: result })
        nextTick()
      }, 25)
      break

    case 'eval':
    case 'evaluate':
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]

      setTimeout(function () {
        try {
          var fnParams = parseFunctionParams(json.callback)
          var fnBody = parseFunctionBody(json.callback)
          var fn = Function(fnParams, fnBody)
          var result = page.evaluate(fn, json.argument)
          emit({ pageIndex: pageIndex, type: 'evaluate', result: result })
        } catch (err) {
          emit({ pageIndex: pageIndex, type: 'evaluate', error: JSON.stringify(err), result: undefined })
        }

        nextTick()
      }, 25)
      break

    case 'close': // single page is closing
      var pageIndex = json.pageIndex
      var page = _pages[pageIndex]
      emit({ debug: 'close -- closing pageIndex: ' + pageIndex })
      page._opened = false
      _pages[pageIndex] = {
        _opened: false,
        _opts: page._opts
      }
      page.close()
      setTimeout(function () {
        emit({ pageIndex: pageIndex, type: 'close', text: 'page closed', result: 'page closed' })
        nextTick()
      }, 25)
      break

    case 'exit': // spawn is exiting (close all pages)
      emit({ debug: 'exit -- closing all pages' })
      _pages.forEach(function (page) {
        page.close && page.close()
      })
      _running = false
      nextTick() // nextTick will phantom.exit() when _running is false
      break

    case 'echo':
      emit(json)
      nextTick()
      break
    default:
      emit({ error: 'unknown type [' + json.type + ']' })
  }
}

function parseFunctionBody (fn) {
  var str = fn.toString()
  return str.substring(
    str.indexOf('{') + 1,
    str.lastIndexOf('}') - 1
  )
}

// return array of function params
function parseFunctionParams (fn) {
  var str = fn.toString()
  return str.substring(
    str.indexOf('(') + 1,
    str.indexOf(')')
  ).split(',')
    .map(function (param) {
      return param.trim()
    })
}
